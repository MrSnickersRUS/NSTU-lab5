# 🦊 Симуляция "Хищник-Жертва"

Программа моделирует взаимодействие хищников и жертв на двумерном поле согласно заданным правилам.

## 🚀 Быстрый старт

### Запуск интерактивного режима
```bash
make run
# или
./predator_prey
```

### Запуск тестовых примеров
```bash
make run-test1          # Пример 1 без визуализации
make run-test1-visual   # Пример 1 с визуализацией
make run-test2          # Пример 2 без визуализации
make run-test2-visual   # Пример 2 с визуализацией
```

### Запуск из командной строки
```bash
./predator_prey -f input.txt          # Без визуализации
./predator_prey -f input.txt -v       # С визуализацией
```

## 📋 Интерактивное меню

При запуске без аргументов программа показывает меню с опциями:

```
Выберите режим работы:
  1. Загрузить из файла
  2. Ввести данные вручную
  3. Сгенерировать случайную симуляцию
  4. Запустить тестовый пример 1 (3×3, 3 хода)
  5. Запустить тестовый пример 2 (4×4, 20 ходов)
  0. Выход
```

### Режимы работы:

#### 1️⃣ Загрузка из файла
- Позволяет загрузить симуляцию из текстового файла
- После загрузки можно выбрать включить ли визуализацию

#### 2️⃣ Ручной ввод
- Запрашивает размеры поля (N×M)
- Количество ходов симуляции (T)
- Количество жертв и хищников
- Координаты и параметры каждого животного

#### 3️⃣ Случайная генерация
- Автоматически создает животных со случайными параметрами
- Нужно указать только размеры поля и количество животных

#### 4️⃣ & 5️⃣ Тестовые примеры
- Запускают предопределенные примеры из задания
- Позволяют быстро проверить корректность работы

## 📝 Формат входного файла

```
N M T      # Размеры поля (ширина×высота) и количество ходов
R W        # Количество жертв и хищников

# Далее R строк для жертв:
x y d k    # x,y - координаты, d - направление (0-3), k - частота смены направления

# Далее W строк для хищников:
x y d k    # Аналогично
```

### Направления:
- `0` - вверх (UP)
- `1` - вправо (RIGHT)
- `2` - вниз (DOWN)
- `3` - влево (LEFT)

### Пример файла:
```
3 3 3
2 1
1 2 1 1
1 1 0 2
0 2 1 2
```

## 🎮 Визуализация

При включении визуализации программа показывает состояние поля на каждом ходу:

```
Шаг: 0 | Животных: 3
· · ·
· R ·
W R ·

Легенда:
· - пустая клетка
R - жертва (Rabbit)
W - хищник (Wolf)
X - обе категории в одной клетке
```

## 📊 Формат вывода

Финальное состояние поля выводится в формате:
- `*` - пустая клетка
- `+k` - k жертв в клетке
- `-k` - k хищников в клетке
- `+n-m` - n жертв и m хищников в одной клетке

## 📁 Структура проекта

```
lab5/
├── Makefile                    # Автоматизация сборки
├── README.md                   # Документация
├── predator_prey               # Исполняемый файл (после компиляции)
│
├── include/                    # Заголовочные файлы
│   ├── animal.h                # Абстрактный базовый класс Animal
│   ├── prey.h                  # Класс Prey (жертва)
│   ├── predator.h              # Класс Predator (хищник)
│   └── simulation.h            # Класс Simulation (управление)
│
├── src/                        # Исходные файлы реализации
│   ├── main.cpp                # Точка входа, интерактивное меню
│   ├── animal.cpp              # Реализация базового класса
│   ├── prey.cpp                # Реализация жертвы
│   ├── predator.cpp            # Реализация хищника
│   └── simulation.cpp          # Реализация симуляции (5 этапов)
│
├── build/                      # Объектные файлы (*.o)
│   ├── animal.o
│   ├── main.o
│   ├── predator.o
│   ├── prey.o
│   └── simulation.o
│
├── input1.txt                  # Тестовые входные данные (пример 1)
├── input2.txt                  # Тестовые входные данные (пример 2)
└── demo_input.txt              # Демонстрационный пример (5×5, 10 ходов)
```

## 🏗️ Архитектура классов

### Иерархия наследования:

```
                    ┌─────────────────────────┐
                    │       Animal            │
                    │   (абстрактный класс)   │
                    ├─────────────────────────┤
                    │ # x, y : int            │
                    │ # dir : Direction       │
                    │ # k : int               │
                    │ # age : int             │
                    │ # stepCounter : int     │
                    ├─────────────────────────┤
                    │ + move() = 0            │ ◄── Чисто виртуальные
                    │ + canReproduce() = 0    │     методы
                    │ + reproduce() = 0       │
                    │ + getType() = 0         │
                    │ + getMaxAge() = 0       │
                    │ + getSpeed() = 0        │
                    │ + incrementAge()        │
                    │ + isDead()              │
                    │ + rotateDirection()     │
                    └───────────┬─────────────┘
                                │
                 ┌──────────────┴──────────────┐
                 │                             │
         ┌───────▼────────┐           ┌───────▼────────┐
         │     Prey       │           │   Predator     │
         │    (жертва)    │           │   (хищник)     │
         ├────────────────┤           ├────────────────┤
         │ - MAX_AGE = 15 │           │ - MAX_AGE = 25 │
         │ - reproCount   │           │ - preyEaten    │
         ├────────────────┤           ├────────────────┤
         │ + move()       │           │ + move()       │
         │   → 1 клетка   │           │   → 2 клетки   │
         │ + reproduce()  │           │ + reproduce()  │
         │   в 5 и 10 лет │           │   после 2 жертв│
         └────────────────┘           └────────────────┘
```

### Класс управления симуляцией:

```
        ┌────────────────────────────────────────┐
        │          Simulation                    │
        ├────────────────────────────────────────┤
        │ - width, height, turns : int           │
        │ - animals : vector<unique_ptr<Animal>> │ ◄── Полиморфизм
        ├────────────────────────────────────────┤
        │ + addAnimal(animal)                    │
        │ + run(visualize)                       │
        │ + printFinalState()                    │
        │ - movePhase()            ──┐           │
        │ - feedingPhase()           │           │
        │ - agingPhase()             ├─ 5 этапов │
        │ - reproductionPhase()      │           │
        │ - extinctionPhase()      ──┘           │
        └────────────────────────────────────────┘
```

## 🔄 Взаимодействие компонентов

```
┌─────────────┐
│   main.cpp  │  ──► Показывает меню
└──────┬──────┘      Читает входные данные
       │
       ▼
┌─────────────────────────────────────────────┐
│  Создание объектов животных                 │
│  ────────────────────────────────────        │
│  new Prey(x, y, dir, k)                     │
│  new Predator(x, y, dir, k)                 │
│                                              │
│  Добавление в Simulation через unique_ptr   │
└──────┬──────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────────┐
│          Simulation::run()                   │
│  ─────────────────────────────────────       │
│  for (turn = 1; turn <= T; turn++)          │
│    │                                         │
│    ├─► 1. movePhase()                       │
│    │     for each animal: animal->move()    │ ◄── Полиморфный вызов
│    │                                         │
│    ├─► 2. feedingPhase()                    │
│    │     Группировка по координатам         │
│    │     Хищник съедает жертв               │
│    │                                         │
│    ├─► 3. agingPhase()                      │
│    │     for each: animal->incrementAge()   │
│    │                                         │
│    ├─► 4. reproductionPhase()               │
│    │     if canReproduce():                 │
│    │       newborn = animal->reproduce()    │ ◄── Factory Method
│    │                                         │
│    └─► 5. extinctionPhase()                 │
│          if animal->isDead(): remove        │
└─────────────────────────────────────────────┘
       │
       ▼
┌─────────────────┐
│ printFinalState │  ──► Вывод результата
└─────────────────┘
```

## 🎯 Ключевые особенности реализации

### 📋 Описание классов:

#### `Animal` (animal.h / animal.cpp)
**Абстрактный базовый класс** для всех животных.

**Данные:**
- `x, y` - координаты на поле
- `dir` - направление движения (UP/RIGHT/DOWN/LEFT)
- `k` - частота смены направления (каждые k ходов)
- `age` - текущий возраст
- `stepCounter` - счетчик для смены направления

**Чисто виртуальные методы (обязательны для переопределения):**
- `move(width, height)` - движение с учетом границ
- `canReproduce()` - проверка условий размножения
- `reproduce()` - создание потомка
- `getType()` - тип животного (PREY/PREDATOR)
- `getMaxAge()` - максимальный возраст
- `getSpeed()` - скорость (1 или 2 клетки)

**Общие методы:**
- `incrementAge()` - увеличить возраст на 1
- `isDead()` - проверка на превышение MAX_AGE
- `rotateDirection()` - поворот по часовой стрелке

#### `Prey` (prey.h / prey.cpp)
**Класс жертвы** (кролик, заяц и т.д.)

**Константы:**
- `MAX_AGE = 15` - умирает в 15 лет
- `FIRST_REPRODUCTION_AGE = 5` - первое размножение
- `SECOND_REPRODUCTION_AGE = 10` - второе размножение

**Особенности:**
- Двигается на **1 клетку** за ход
- Размножается **дважды** за жизнь (в 5 и 10 лет)
- Может быть съедена хищником

#### `Predator` (predator.h / predator.cpp)
**Класс хищника** (волк, лиса и т.д.)

**Константы:**
- `MAX_AGE = 25` - умирает в 25 лет (дольше жертв!)
- `PREY_TO_REPRODUCE = 2` - нужно съесть 2 жертвы

**Особенности:**
- Двигается на **2 клетки** за ход
- Размножается после поедания **2-х жертв**
- Метод `eatPrey()` увеличивает счетчик съеденных
- Метод `resetSatiety()` обнуляет счетчик после размножения

#### `Simulation` (simulation.h / simulation.cpp)
**Класс управления симуляцией**

**Данные:**
- `width, height` - размеры поля
- `turns` - количество ходов
- `animals` - вектор `unique_ptr<Animal>` (полиморфизм!)

**Публичные методы:**
- `addAnimal(animal)` - добавить животное
- `run(visualize)` - запустить симуляцию
- `printFinalState()` - вывести результат
- `visualizeStep(step)` - показать поле

**Приватные методы (5 этапов каждого хода):**

1. **`movePhase()`** - Движение
   - Вызывает `animal->move()` для каждого животного
   - Учитывает тороидальные границы (периодические)
   - Проверяет смену направления (каждые k ходов)

2. **`feedingPhase()`** - Питание
   - Группирует животных по координатам `groupByPosition()`
   - Если в клетке есть хищник И жертва:
     - Первый хищник съедает **всех** жертв
     - Вызывает `predator->eatPrey()` для каждой жертвы
     - Удаляет съеденных из вектора `animals`

3. **`agingPhase()`** - Старение
   - Вызывает `animal->incrementAge()` для всех

4. **`reproductionPhase()`** - Размножение
   - Проверяет `animal->canReproduce()` для каждого
   - Вызывает `animal->reproduce()` → создает `unique_ptr` потомка
   - Потомок наследует: позицию, направление, параметр k
   - Для хищника: сбрасывает счетчик через `resetSatiety()`
   - Для жертвы: увеличивает счетчик размножений

5. **`extinctionPhase()`** - Вымирание
   - Удаляет животных, где `animal->isDead()` == true
   - Использует `std::remove_if` + `erase`

## 🎨 Паттерны проектирования

**1. Strategy (Стратегия)**
```cpp
// Разные алгоритмы движения и размножения для Prey/Predator
animal->move();        // Prey: 1 клетка, Predator: 2 клетки
animal->canReproduce(); // Prey: по возрасту, Predator: по сытости
```

**2. Template Method (Шаблонный метод)**
```cpp
// Animal задает общий алгоритм, наследники реализуют детали
class Animal {
    void incrementAge() { age++; }  // Общее для всех
    virtual void move() = 0;         // Каждый по-своему
};
```

**3. Factory Method (Фабричный метод)**
```cpp
// Каждый класс создает экземпляр своего типа
std::unique_ptr<Animal> Prey::reproduce() const {
    return std::make_unique<Prey>(x, y, dir, k);
}
```

**4. Composite (Компоновщик)**
```cpp
// Simulation управляет коллекцией Animal как единым целым
std::vector<std::unique_ptr<Animal>> animals;
for (auto& animal : animals) { animal->move(); }
```

## 🔧 Ключевые технологии C++

**Умные указатели (Smart Pointers):**
```cpp
std::unique_ptr<Animal>  // Эксклюзивное владение
std::vector<std::unique_ptr<Animal>> animals;  // Автоматическое удаление
```

**Виртуальные функции (Polymorphism):**
```cpp
virtual void move() = 0;  // Чисто виртуальная (abstract)
virtual ~Animal() = default;  // Виртуальный деструктор
```

**Перечисления (Enum Classes):**
```cpp
enum class Direction { UP, RIGHT, DOWN, LEFT };
enum class AnimalType { PREY, PREDATOR };
```

**Лямбда-функции:**
```cpp
std::remove_if(animals.begin(), animals.end(),
    [](const auto& animal) { return animal->isDead(); });
```

## 🛠️ Make команды

```bash
make                  # Компиляция проекта
make run              # Интерактивный режим
make run-interactive  # Интерактивный режим (явно)
make run-test1        # Тестовый пример 1
make run-test1-visual # Тестовый пример 1 с визуализацией
make run-test2        # Тестовый пример 2
make run-test2-visual # Тестовый пример 2 с визуализацией
make clean            # Очистка
make help             # Справка
```

## 📦 Зависимости

- C++17
- g++ или совместимый компилятор
